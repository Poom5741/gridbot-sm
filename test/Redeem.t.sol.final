// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import {StdCheats} from "forge-std/StdCheats.sol";
import {DepositCertificate} from "../src/DepositCertificate.sol";
import {MockUSDT} from "../src/MockUSDT.sol";

contract RedeemTest is Test {
    DepositCertificate public depositCertificate;
    MockUSDT public usdt;

    address public owner;
    address public user1;
    address public settlementWallet;

    address public ivWallet;
    address public dvWallet;
    address public adWallet;
    address public mlWallet;
    address public bcWallet;
    address public ml1Wallet;
    address public ml2Wallet;
    address public ml3Wallet;

    uint256 public initialAmount = 1000 * 10**6;

    function setUp() public {
        owner = makeAddr("owner");
        user1 = makeAddr("user1");
        settlementWallet = makeAddr("settlementWallet");

        ivWallet = makeAddr("ivWallet");
        dvWallet = makeAddr("dvWallet");
        adWallet = makeAddr("adWallet");
        mlWallet = makeAddr("mlWallet");
        bcWallet = makeAddr("bcWallet");
        ml1Wallet = makeAddr("ml1Wallet");
        ml2Wallet = makeAddr("ml2Wallet");
        ml3Wallet = makeAddr("ml3Wallet");

        vm.prank(owner);
        usdt = new MockUSDT("Mock USDT", "USDT");

        vm.prank(owner);
        depositCertificate = new DepositCertificate(
            address(usdt),
            settlementWallet,
            ivWallet,
            dvWallet,
            adWallet,
            mlWallet,
            bcWallet,
            ml1Wallet,
            ml2Wallet,
            ml3Wallet
        );

        mintUsdtTo(user1, initialAmount);
        mintUsdtTo(settlementWallet, initialAmount * 10);

        approveUsdt(user1, address(depositCertificate), initialAmount);
        approveUsdt(settlementWallet, address(depositCertificate), initialAmount * 10);
    }

    function mintUsdtTo(address to, uint256 amount) internal {
        vm.prank(owner);
        usdt.mint(to, amount);
    }

    function approveUsdt(address from, address spender, uint256 amount) internal {
        vm.prank(from);
        usdt.approve(spender, amount);
    }

    function warpTime(uint256 _seconds) internal {
        vm.warp(block.timestamp + _seconds);
    }

    function test_SetUp() public view {
        assert(address(depositCertificate) != address(0));
        assert(address(usdt) != address(0));
        assertEq(usdt.balanceOf(user1), initialAmount);
        assertEq(usdt.allowance(user1, address(depositCertificate)), initialAmount);
        assertEq(depositCertificate.ivWallet(), ivWallet);
    }

    function test_redeem_successful_no_penalty() public {
        uint256 depositAmount = 100 * 10**6;

        vm.prank(user1);
        depositCertificate.deposit(depositAmount, ml1Wallet, ml2Wallet, ml3Wallet);

        warpTime(5 * 365 days);

        uint256 user1UsdtBalanceBefore = usdt.balanceOf(user1);
        uint256 settlementWalletUsdtBalanceBefore = usdt.balanceOf(settlementWallet);
        uint256 user1CertificateBalanceBefore = depositCertificate.balanceOf(user1);

        vm.prank(user1);
        depositCertificate.redeem(depositAmount);

        assertEq(depositCertificate.balanceOf(user1), user1CertificateBalanceBefore - depositAmount);
        assertEq(usdt.balanceOf(user1), user1UsdtBalanceBefore + depositAmount);
        assertEq(usdt.balanceOf(settlementWallet), settlementWalletUsdtBalanceBefore - depositAmount);
    }

    function test_redeem_successful_partial_penalty() public {
        uint256 depositAmount = 100 * 10**6;

        vm.prank(user1);
        depositCertificate.deposit(depositAmount, ml1Wallet, ml2Wallet, ml3Wallet);

        warpTime(2 * 365 days + 182 days);

        (uint256 penaltyAmount, uint256 payoutAmount) = depositCertificate.calculatePenalty(user1, depositAmount);

        uint256 user1UsdtBalanceBefore = usdt.balanceOf(user1);
        uint256 settlementWalletUsdtBalanceBefore = usdt.balanceOf(settlementWallet);
        uint256 user1CertificateBalanceBefore = depositCertificate.balanceOf(user1);

        vm.prank(user1);
        depositCertificate.redeem(depositAmount);

        assertEq(depositCertificate.balanceOf(user1), user1CertificateBalanceBefore - depositAmount);
        assertEq(usdt.balanceOf(user1), user1UsdtBalanceBefore + payoutAmount);
        assertEq(usdt.balanceOf(settlementWallet), settlementWalletUsdtBalanceBefore - payoutAmount);
        assertTrue(penaltyAmount > 0 && penaltyAmount < depositAmount / 2);
    }

    function test_redeem_successful_max_penalty() public {
        uint256 depositAmount = 100 * 10**6;

        vm.prank(user1);
        depositCertificate.deposit(depositAmount, ml1Wallet, ml2Wallet, ml3Wallet);

        warpTime(182 days);

        (uint256 penaltyAmount, uint256 payoutAmount) = depositCertificate.calculatePenalty(user1, depositAmount);

        uint256 user1UsdtBalanceBefore = usdt.balanceOf(user1);
        uint256 settlementWalletUsdtBalanceBefore = usdt.balanceOf(settlementWallet);
        uint256 user1CertificateBalanceBefore = depositCertificate.balanceOf(user1);

        vm.prank(user1);
        depositCertificate.redeem(depositAmount);

        assertEq(depositCertificate.balanceOf(user1), user1CertificateBalanceBefore - depositAmount);
        assertEq(usdt.balanceOf(user1), user1UsdtBalanceBefore + payoutAmount);
        assertEq(usdt.balanceOf(settlementWallet), settlementWalletUsdtBalanceBefore - payoutAmount);
        assertEq(penaltyAmount, depositAmount / 2);
    }

    function test_redeem_fails_insufficient_balance() public {
        uint256 depositAmount = 100 * 10**6;
        uint256 redeemAmount = depositAmount + 1;

        vm.prank(user1);
        depositCertificate.deposit(depositAmount, ml1Wallet, ml2Wallet, ml3Wallet);

        vm.prank(user1);
        vm.expectRevert("Insufficient certificate token balance");
        depositCertificate.redeem(redeemAmount);
    }

    function test_redeem_fails_zero_amount() public {
        uint256 depositAmount = 100 * 10**6;

        vm.prank(user1);
        depositCertificate.deposit(depositAmount, ml1Wallet, ml2Wallet, ml3Wallet);

        vm.prank(user1);
        vm.expectRevert("Redeem amount must be greater than zero");
        depositCertificate.redeem(0);
    }

    function test_redeem_fails_no_certificates() public {
        uint256 redeemAmount = 100 * 10**6;
        address user2 = makeAddr("user2");

        vm.prank(user2);
        vm.expectRevert("Insufficient certificate token balance");
        depositCertificate.redeem(redeemAmount);
    }
}
